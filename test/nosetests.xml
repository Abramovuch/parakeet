<?xml version="1.0" encoding="UTF-8"?><testsuite name="nosetests" tests="150" errors="0" failures="2" skip="0"><testcase classname="test_adverb_semantics" name="test_map_1d" time="0.000" /><testcase classname="test_adverb_semantics" name="test_map_2d" time="0.000" /><testcase classname="test_adverb_semantics" name="test_reduce_1d" time="0.000" /><testcase classname="test_adverb_semantics" name="test_reduce_2d" time="0.000" /><testcase classname="test_adverb_semantics" name="test_bool_sum" time="0.000" /><testcase classname="test_adverb_semantics" name="test_scan_1d" time="0.000" /><testcase classname="test_adverb_semantics" name="test_scan_2d" time="0.000" /><testcase classname="test_adverb_semantics" name="test_allpairs" time="0.001" /><testcase classname="test_allpairs" name="test_loop_outer_prod" time="0.894" /><testcase classname="test_allpairs" name="test_adverb_outer_prod" time="1.187" /><testcase classname="test_allpairs" name="test_loop_matmult" time="0.879" /><testcase classname="test_allpairs" name="test_loop_matmult_timing" time="0.141" /><testcase classname="test_allpairs" name="test_adverb_matmult" time="1.049" /><testcase classname="test_arrays" name="test_create_const" time="0.051" /><testcase classname="test_arrays" name="test_index_1d" time="0.033" /><testcase classname="test_arrays" name="test_index_2d" time="0.045" /><testcase classname="test_arrays" name="test_index_3d" time="0.057" /><testcase classname="test_arrays" name="test_set_idx_1d" time="0.037" /><testcase classname="test_arrays" name="test_set_idx_2d" time="0.049" /><testcase classname="test_arrays" name="test_set_idx_3d" time="0.060" /><testcase classname="test_black_scholes" name="test_black_scholes" time="0.409" /><testcase classname="test_cast" name="test_implicit_to_float" time="0.018" /><testcase classname="test_cast" name="test_implicit_to_bool" time="0.020" /><testcase classname="test_col_sum" name="test_each_col_sum" time="7.561" /><testcase classname="test_dist" name="test_dists" time="0.236" /><testcase classname="test_dot" name="test_loopdot" time="0.632" /><testcase classname="test_dot" name="test_adverb_dot" time="0.123"><failure type="exceptions.AssertionError" message="Expected 3 but untyped fn returned  True&#10;-------------------- &gt;&gt; begin captured stdout &lt;&lt; ---------------------&#10;[ast_conversion] Translated &lt;function dot at 0x43ccf50&gt; into untyped function:&#10;def dot.6(x.73{x}, y.47{y}):&#10;    Return def Reduce_wrapper(combine{combine}, x.56{x}, init{init} = None):&#10;        Return Reduce(axis = 0 : int64, args = (x.56), type = None, init = init, map_fn = def identity(x{x}):&#10;            Return x, combine = combine)(prim(add), x.73 * y.47)&#10;=== Specialized multiply_broadcast1 for input types array1(bool), array1(bool) ===&#10;&#10;function multiply_broadcast1.6(x.75 : array1(bool), y.49 : array1(bool)) =&gt; array1(bool):&#10;    Return Map(axis = 0, args = (x.75:array1(bool), y.49:array1(bool)), type=array1(bool), fn = function multiply.65(a.32 : bool, b.18 : bool) =&gt; bool:&#10;        Return a.32 * b.18)&#10;&#10;=== Specialized identity for input types bool ===&#10;&#10;function identity.4(x.77 : bool) =&gt; bool:&#10;    Return x.77&#10;&#10;=== Specialized add for input types bool, bool ===&#10;&#10;function add.42(a.48 : bool, b.34 : bool) =&gt; bool:&#10;    Return a.48 + b.34&#10;&#10;=== Specialized Reduce_wrapper for input types ClosT(add, {}), array1(bool) ===&#10;&#10;function Reduce_wrapper.3(combine.4 : ClosT(add, {}), x.76 : array1(bool)) =&gt; bool:&#10;    init.3 : NoneT = None&#10;    Return Reduce(axis = 0, args = (x.76:array1(bool)), type = bool, init = None, map_fn = function identity.4(x.77 : bool) =&gt; bool:&#10;        Return x.77, combine = function add.42(a.48 : bool, b.34 : bool) =&gt; bool:&#10;        Return a.48 + b.34)&#10;&#10;prefix temp&#10;ssa_id temp.105&#10;type array1(bool)&#10;=== Specialized dot.6 for input types array1(bool), array1(bool) ===&#10;&#10;function dot.7(x.74 : array1(bool), y.48 : array1(bool)) =&gt; bool:&#10;    temp.105 : array1(bool) = function multiply_broadcast1.6(x.75 : array1(bool), y.49 : array1(bool)) =&gt; array1(bool):&#10;        Return Map(axis = 0, args = (x.75:array1(bool), y.49:array1(bool)), type=array1(bool), fn = function multiply.65(a.32 : bool, b.18 : bool) =&gt; bool:&#10;            Return a.32 * b.18)(x.74, y.48)&#10;    Return function Reduce_wrapper.3(combine.4 : ClosT(add, {}), x.76 : array1(bool)) =&gt; bool:&#10;        init.3 : NoneT = None&#10;        Return Reduce(axis = 0, args = (x.76:array1(bool)), type = bool, init = None, map_fn = function identity.4(x.77 : bool) =&gt; bool:&#10;            Return x.77, combine = function add.42(a.48 : bool, b.34 : bool) =&gt; bool:&#10;            Return a.48 + b.34)(Closure(fixed_args = {}, def add(a.20, b.6):&#10;        Return a.20 + b.6), temp.105)&#10;&#10;prefix shape&#10;ssa_id shape.72&#10;type tuple(int64)&#10;prefix dim0&#10;ssa_id dim0.47&#10;type int64&#10;prefix shape&#10;ssa_id shape.73&#10;type tuple(int64)&#10;prefix dim0&#10;ssa_id dim0.48&#10;type int64&#10;prefix array_elt&#10;ssa_id array_elt.183&#10;type bool&#10;prefix array_elt&#10;ssa_id array_elt.184&#10;type bool&#10;prefix call_result&#10;ssa_id call_result.39&#10;type bool&#10;prefix acc&#10;ssa_id acc.43&#10;type bool&#10;prefix i&#10;ssa_id i.172&#10;type int64&#10;prefix array_elt&#10;ssa_id array_elt.185&#10;type bool&#10;prefix array_elt&#10;ssa_id array_elt.186&#10;type bool&#10;prefix call_result&#10;ssa_id call_result.40&#10;type bool&#10;prefix call_result&#10;ssa_id call_result.41&#10;type bool&#10;prefix acc&#10;ssa_id acc.44&#10;type bool&#10;prefix data&#10;ssa_id data.170&#10;type ptr(bool)&#10;prefix strides&#10;ssa_id strides.196&#10;type tuple(int64)&#10;prefix offset&#10;ssa_id offset.167&#10;type int64&#10;prefix data&#10;ssa_id data.171&#10;type ptr(bool)&#10;prefix strides&#10;ssa_id strides.197&#10;type tuple(int64)&#10;prefix offset&#10;ssa_id offset.168&#10;type int64&#10;prefix data&#10;ssa_id data.172&#10;type ptr(bool)&#10;prefix strides&#10;ssa_id strides.198&#10;type tuple(int64)&#10;prefix offset&#10;ssa_id offset.169&#10;type int64&#10;prefix offset_elts_0&#10;ssa_id offset_elts_0.207&#10;type int64&#10;prefix total_offset&#10;ssa_id total_offset.303&#10;type int64&#10;prefix data&#10;ssa_id data.173&#10;type ptr(bool)&#10;prefix strides&#10;ssa_id strides.199&#10;type tuple(int64)&#10;prefix offset&#10;ssa_id offset.170&#10;type int64&#10;prefix offset_elts_0&#10;ssa_id offset_elts_0.208&#10;type int64&#10;prefix total_offset&#10;ssa_id total_offset.304&#10;type int64&#10;prefix strides_elt0&#10;ssa_id strides_elt0.148&#10;type int64&#10;prefix strides_elt0&#10;ssa_id strides_elt0.149&#10;type int64&#10;prefix loop_counter&#10;ssa_id loop_counter.16&#10;type int64&#10;prefix subtract&#10;ssa_id subtract.9&#10;type int64&#10;prefix divide&#10;ssa_id divide.25&#10;type int64&#10;prefix multiply&#10;ssa_id multiply.413&#10;type int64&#10;&#10;=== Lowered function ===&#10;&#10;function dot.7(x.74 : array1(bool), y.48 : array1(bool)) =&gt; bool:&#10;    shape.72 : tuple(int64) = attr(x.74, 'shape')&#10;    dim0.47 : int64 = attr(shape.72, 'elt0')&#10;    data.170 : ptr(bool) = attr(x.74, 'data')&#10;    offset.167 : int64 = attr(x.74, 'offset')&#10;    array_elt.183 : bool = data.170[offset.167]&#10;    data.171 : ptr(bool) = attr(y.48, 'data')&#10;    offset.168 : int64 = attr(y.48, 'offset')&#10;    array_elt.184 : bool = data.171[offset.168]&#10;    result.150 : bool = array_elt.183 * array_elt.184&#10;    subtract.9 : int64 = dim0.47 - 1 : int64&#10;    divide.25 : int64 = subtract.9 / 4 : int64&#10;    multiply.413 : int64 = divide.25 * 4 : int64&#10;    for loop_counter.16 in range(1, 1 : int64 + multiply.413, 4):&#10;      (header)&#10;        acc.45 &lt;- phi(result.150, result.160)&#10;      (body)&#10;        total_offset.305 : int64 = offset.167 + loop_counter.16&#10;        array_elt.187 : bool = data.170[total_offset.305]&#10;        total_offset.306 : int64 = offset.168 + loop_counter.16&#10;        array_elt.188 : bool = data.171[total_offset.306]&#10;        result.153 : bool = array_elt.187 * array_elt.188&#10;        result.154 : bool = acc.45 + result.153&#10;        i.174 : int64 = loop_counter.16 + 1 : int64&#10;        total_offset.307 : int64 = offset.167 + i.174&#10;        array_elt.189 : bool = data.170[total_offset.307]&#10;        total_offset.308 : int64 = offset.168 + i.174&#10;        array_elt.190 : bool = data.171[total_offset.308]&#10;        result.155 : bool = array_elt.189 * array_elt.190&#10;        result.156 : bool = result.154 + result.155&#10;        i.175 : int64 = loop_counter.16 + 2 : int64&#10;        total_offset.309 : int64 = offset.167 + i.175&#10;        array_elt.191 : bool = data.170[total_offset.309]&#10;        total_offset.310 : int64 = offset.168 + i.175&#10;        array_elt.192 : bool = data.171[total_offset.310]&#10;        result.157 : bool = array_elt.191 * array_elt.192&#10;        result.158 : bool = result.156 + result.157&#10;        i.176 : int64 = loop_counter.16 + 3 : int64&#10;        total_offset.311 : int64 = offset.167 + i.176&#10;        array_elt.193 : bool = data.170[total_offset.311]&#10;        total_offset.312 : int64 = offset.168 + i.176&#10;        array_elt.194 : bool = data.171[total_offset.312]&#10;        result.159 : bool = array_elt.193 * array_elt.194&#10;        result.160 : bool = result.158 + result.159&#10;    for i.172 in range(1 : int64 + multiply.413, dim0.47, 1):&#10;      (header)&#10;        acc.43 &lt;- phi(acc.45, result.152)&#10;      (body)&#10;        total_offset.303 : int64 = offset.167 + i.172&#10;        array_elt.185 : bool = data.170[total_offset.303]&#10;        total_offset.304 : int64 = offset.168 + i.172&#10;        array_elt.186 : bool = data.171[total_offset.304]&#10;        result.151 : bool = array_elt.185 * array_elt.186&#10;        result.152 : bool = acc.43 + result.151&#10;    Return acc.43&#10;&#10;&#10;--------------------- &gt;&gt; end captured stdout &lt;&lt; ----------------------"><![CDATA[Traceback (most recent call last):
  File "/usr/lib/python2.7/unittest/case.py", line 327, in run
    testMethod()
  File "/usr/lib/python2.7/dist-packages/nose/case.py", line 197, in runTest
    self.test(*self.arg)
  File "/home/iskander/code/parakeet/tests/test_dot.py", line 27, in test_adverb_dot
    expect_allpairs(dot, lambda x,y: np.sum(x*y), vectors)
  File "/home/iskander/code/parakeet/tests/testing_helpers.py", line 91, in expect_allpairs
    expect(parakeet_fn, [x,y], python_fn(x,y))
  File "/home/iskander/code/parakeet/tests/testing_helpers.py", line 72, in expect
    "Expected %s but untyped fn returned  %s" % (expected, untyped_result)
AssertionError: Expected 3 but untyped fn returned  True
-------------------- >> begin captured stdout << ---------------------
[ast_conversion] Translated <function dot at 0x43ccf50> into untyped function:
def dot.6(x.73{x}, y.47{y}):
    Return def Reduce_wrapper(combine{combine}, x.56{x}, init{init} = None):
        Return Reduce(axis = 0 : int64, args = (x.56), type = None, init = init, map_fn = def identity(x{x}):
            Return x, combine = combine)(prim(add), x.73 * y.47)
=== Specialized multiply_broadcast1 for input types array1(bool), array1(bool) ===

function multiply_broadcast1.6(x.75 : array1(bool), y.49 : array1(bool)) => array1(bool):
    Return Map(axis = 0, args = (x.75:array1(bool), y.49:array1(bool)), type=array1(bool), fn = function multiply.65(a.32 : bool, b.18 : bool) => bool:
        Return a.32 * b.18)

=== Specialized identity for input types bool ===

function identity.4(x.77 : bool) => bool:
    Return x.77

=== Specialized add for input types bool, bool ===

function add.42(a.48 : bool, b.34 : bool) => bool:
    Return a.48 + b.34

=== Specialized Reduce_wrapper for input types ClosT(add, {}), array1(bool) ===

function Reduce_wrapper.3(combine.4 : ClosT(add, {}), x.76 : array1(bool)) => bool:
    init.3 : NoneT = None
    Return Reduce(axis = 0, args = (x.76:array1(bool)), type = bool, init = None, map_fn = function identity.4(x.77 : bool) => bool:
        Return x.77, combine = function add.42(a.48 : bool, b.34 : bool) => bool:
        Return a.48 + b.34)

prefix temp
ssa_id temp.105
type array1(bool)
=== Specialized dot.6 for input types array1(bool), array1(bool) ===

function dot.7(x.74 : array1(bool), y.48 : array1(bool)) => bool:
    temp.105 : array1(bool) = function multiply_broadcast1.6(x.75 : array1(bool), y.49 : array1(bool)) => array1(bool):
        Return Map(axis = 0, args = (x.75:array1(bool), y.49:array1(bool)), type=array1(bool), fn = function multiply.65(a.32 : bool, b.18 : bool) => bool:
            Return a.32 * b.18)(x.74, y.48)
    Return function Reduce_wrapper.3(combine.4 : ClosT(add, {}), x.76 : array1(bool)) => bool:
        init.3 : NoneT = None
        Return Reduce(axis = 0, args = (x.76:array1(bool)), type = bool, init = None, map_fn = function identity.4(x.77 : bool) => bool:
            Return x.77, combine = function add.42(a.48 : bool, b.34 : bool) => bool:
            Return a.48 + b.34)(Closure(fixed_args = {}, def add(a.20, b.6):
        Return a.20 + b.6), temp.105)

prefix shape
ssa_id shape.72
type tuple(int64)
prefix dim0
ssa_id dim0.47
type int64
prefix shape
ssa_id shape.73
type tuple(int64)
prefix dim0
ssa_id dim0.48
type int64
prefix array_elt
ssa_id array_elt.183
type bool
prefix array_elt
ssa_id array_elt.184
type bool
prefix call_result
ssa_id call_result.39
type bool
prefix acc
ssa_id acc.43
type bool
prefix i
ssa_id i.172
type int64
prefix array_elt
ssa_id array_elt.185
type bool
prefix array_elt
ssa_id array_elt.186
type bool
prefix call_result
ssa_id call_result.40
type bool
prefix call_result
ssa_id call_result.41
type bool
prefix acc
ssa_id acc.44
type bool
prefix data
ssa_id data.170
type ptr(bool)
prefix strides
ssa_id strides.196
type tuple(int64)
prefix offset
ssa_id offset.167
type int64
prefix data
ssa_id data.171
type ptr(bool)
prefix strides
ssa_id strides.197
type tuple(int64)
prefix offset
ssa_id offset.168
type int64
prefix data
ssa_id data.172
type ptr(bool)
prefix strides
ssa_id strides.198
type tuple(int64)
prefix offset
ssa_id offset.169
type int64
prefix offset_elts_0
ssa_id offset_elts_0.207
type int64
prefix total_offset
ssa_id total_offset.303
type int64
prefix data
ssa_id data.173
type ptr(bool)
prefix strides
ssa_id strides.199
type tuple(int64)
prefix offset
ssa_id offset.170
type int64
prefix offset_elts_0
ssa_id offset_elts_0.208
type int64
prefix total_offset
ssa_id total_offset.304
type int64
prefix strides_elt0
ssa_id strides_elt0.148
type int64
prefix strides_elt0
ssa_id strides_elt0.149
type int64
prefix loop_counter
ssa_id loop_counter.16
type int64
prefix subtract
ssa_id subtract.9
type int64
prefix divide
ssa_id divide.25
type int64
prefix multiply
ssa_id multiply.413
type int64

=== Lowered function ===

function dot.7(x.74 : array1(bool), y.48 : array1(bool)) => bool:
    shape.72 : tuple(int64) = attr(x.74, 'shape')
    dim0.47 : int64 = attr(shape.72, 'elt0')
    data.170 : ptr(bool) = attr(x.74, 'data')
    offset.167 : int64 = attr(x.74, 'offset')
    array_elt.183 : bool = data.170[offset.167]
    data.171 : ptr(bool) = attr(y.48, 'data')
    offset.168 : int64 = attr(y.48, 'offset')
    array_elt.184 : bool = data.171[offset.168]
    result.150 : bool = array_elt.183 * array_elt.184
    subtract.9 : int64 = dim0.47 - 1 : int64
    divide.25 : int64 = subtract.9 / 4 : int64
    multiply.413 : int64 = divide.25 * 4 : int64
    for loop_counter.16 in range(1, 1 : int64 + multiply.413, 4):
      (header)
        acc.45 <- phi(result.150, result.160)
      (body)
        total_offset.305 : int64 = offset.167 + loop_counter.16
        array_elt.187 : bool = data.170[total_offset.305]
        total_offset.306 : int64 = offset.168 + loop_counter.16
        array_elt.188 : bool = data.171[total_offset.306]
        result.153 : bool = array_elt.187 * array_elt.188
        result.154 : bool = acc.45 + result.153
        i.174 : int64 = loop_counter.16 + 1 : int64
        total_offset.307 : int64 = offset.167 + i.174
        array_elt.189 : bool = data.170[total_offset.307]
        total_offset.308 : int64 = offset.168 + i.174
        array_elt.190 : bool = data.171[total_offset.308]
        result.155 : bool = array_elt.189 * array_elt.190
        result.156 : bool = result.154 + result.155
        i.175 : int64 = loop_counter.16 + 2 : int64
        total_offset.309 : int64 = offset.167 + i.175
        array_elt.191 : bool = data.170[total_offset.309]
        total_offset.310 : int64 = offset.168 + i.175
        array_elt.192 : bool = data.171[total_offset.310]
        result.157 : bool = array_elt.191 * array_elt.192
        result.158 : bool = result.156 + result.157
        i.176 : int64 = loop_counter.16 + 3 : int64
        total_offset.311 : int64 = offset.167 + i.176
        array_elt.193 : bool = data.170[total_offset.311]
        total_offset.312 : int64 = offset.168 + i.176
        array_elt.194 : bool = data.171[total_offset.312]
        result.159 : bool = array_elt.193 * array_elt.194
        result.160 : bool = result.158 + result.159
    for i.172 in range(1 : int64 + multiply.413, dim0.47, 1):
      (header)
        acc.43 <- phi(acc.45, result.152)
      (body)
        total_offset.303 : int64 = offset.167 + i.172
        array_elt.185 : bool = data.170[total_offset.303]
        total_offset.304 : int64 = offset.168 + i.172
        array_elt.186 : bool = data.171[total_offset.304]
        result.151 : bool = array_elt.185 * array_elt.186
        result.152 : bool = acc.43 + result.151
    Return acc.43


--------------------- >> end captured stdout << ----------------------
]]></failure></testcase><testcase classname="test_escape_analysis" name="test_escape_analysis" time="0.000" /><testcase classname="test_fancy_indexing" name="test_1d_by_1d" time="0.230" /><testcase classname="test_fancy_indexing" name="test_2d_by_idx" time="0.266" /><testcase classname="test_floyd_warshall" name="test_dists" time="0.597" /><testcase classname="test_floyd_warshall" name="test_dist_perf" time="1.578" /><testcase classname="test_gaussian_blur" name="test_blur" time="0.696" /><testcase classname="test_harris_corner" name="test_diff_x" time="0.671" /><testcase classname="test_harris_corner" name="test_diff_y" time="0.069" /><testcase classname="test_harris_corner" name="test_harris" time="2.822" /><testcase classname="test_harris_corner" name="test_harris_timing" time="1.107" /><testcase classname="test_indexing" name="test_index_1d" time="0.034" /><testcase classname="test_indexing" name="test_index_2d" time="0.046" /><testcase classname="test_indexing" name="test_index_3d" time="0.057" /><testcase classname="test_indexing" name="test_set_idx_1d" time="0.038" /><testcase classname="test_indexing" name="test_set_idx_2d" time="0.050" /><testcase classname="test_indexing" name="test_set_idx_3d" time="0.061" /><testcase classname="test_kmeans" name="test_kmeans" time="0.239" /><testcase classname="test_kmeans" name="test_kmeans_perf" time="0.006" /><testcase classname="test_list_comp" name="test_identity_comprehension" time="0.089" /><testcase classname="test_list_comp" name="test_sqr_elts" time="0.096" /><testcase classname="test_list_comp" name="test_outer_prod" time="0.160" /><testcase classname="test_list_comp" name="test_triple_nesting" time="0.223" /><testcase classname="test_loops" name="test_for_range_loop" time="0.033" /><testcase classname="test_loops" name="test_count_loop" time="0.471" /><testcase classname="test_loops" name="test_nested_double_count" time="0.098" /><testcase classname="test_loops" name="test_nested_mult" time="0.102" /><testcase classname="test_loops" name="test_conditional_loop" time="0.025" /><testcase classname="test_map" name="test_add1_external_map" time="0.091" /><testcase classname="test_map" name="test_add1_internal_map_vecs" time="0.477" /><testcase classname="test_map" name="test_add1_internal_map_matrices" time="0.526" /><testcase classname="test_map" name="test_implicit_add_vec" time="1.484" /><testcase classname="test_map" name="test_implicit_add_mat" time="1.174" /><testcase classname="test_map" name="test_explicit_add_vec" time="1.849" /><testcase classname="test_map" name="test_explicit_add_mat" time="1.166" /><testcase classname="test_map" name="test_conditional_div" time="0.985" /><testcase classname="test_map" name="test_second_of_columns" time="0.101" /><testcase classname="test_map" name="test_second_of_rows" time="0.101" /><testcase classname="test_map" name="test_nested_each" time="0.127" /><testcase classname="test_map" name="test_map_map" time="0.142" /><testcase classname="test_mutability_analysis" name="test_mutable_array" time="0.011" /><testcase classname="test_nn" name="test_nn" time="0.208" /><testcase classname="test_optimizations" name="test_inline" time="0.013" /><testcase classname="test_optimizations" name="test_simple_constant_folding" time="0.008" /><testcase classname="test_optimizations" name="test_constants_across_control_flow" time="0.008" /><testcase classname="test_optimizations" name="test_always_true" time="0.008" /><testcase classname="test_optimizations" name="test_always_false" time="0.007" /><testcase classname="test_optimizations" name="test_volatile_licm_mistake" time="0.053" /><testcase classname="test_optimizations" name="test_copy_elimination" time="0.163" /><testcase classname="test_par_each" name="test_add1" time="0.149" /><testcase classname="test_reduce" name="test_int_sum" time="0.169" /><testcase classname="test_reduce" name="test_float_sum" time="0.168" /><testcase classname="test_reduce" name="test_bool_sum" time="0.285" /><testcase classname="test_reduce" name="test_2d_reduce" time="0.320" /><testcase classname="test_reduce" name="test_sqr_dist" time="0.202" /><testcase classname="test_rule_30" name="test_rule30" time="1.205" /><testcase classname="test_scan" name="test_scan_add_1d" time="0.214" /><testcase classname="test_scan" name="test_scan_add_2d" time="0.574" /><testcase classname="test_shape_inference" name="test_const_scalar" time="0.004" /><testcase classname="test_shape_inference" name="test_any_scalar" time="0.007" /><testcase classname="test_shape_inference" name="test_array_literal" time="0.014" /><testcase classname="test_shape_inference" name="test_ident_1d" time="0.005" /><testcase classname="test_shape_inference" name="test_ident_2d" time="0.005" /><testcase classname="test_shape_inference" name="test_increase_rank_1d" time="0.014" /><testcase classname="test_shape_inference" name="test_increase_rank_2d" time="0.129" /><testcase classname="test_shape_inference" name="test_increase_rank_3d" time="0.170" /><testcase classname="test_shape_inference" name="test_simple_map_1d" time="0.084" /><testcase classname="test_shape_inference" name="test_simple_map_2d" time="0.137" /><testcase classname="test_shape_inference" name="test_map_increase_rank_1d" time="0.105" /><testcase classname="test_shape_inference" name="test_map_increase_rank_2d" time="0.000" /><testcase classname="test_simple" name="test_always1" time="0.005" /><testcase classname="test_simple" name="test_always_neg10" time="0.004" /><testcase classname="test_simple" name="test_add1" time="0.009" /><testcase classname="test_simple" name="test_call_add1" time="0.009" /><testcase classname="test_simple" name="test_nested_ident" time="0.008" /><testcase classname="test_simple" name="test_use_global" time="0.007" /><testcase classname="test_simple" name="test_if_exp" time="0.011" /><testcase classname="test_simple" name="test_simple_branch" time="0.011" /><testcase classname="test_simple" name="test_simple_merge" time="0.011" /><testcase classname="test_simple" name="test_one_sided_merge" time="0.010" /><testcase classname="test_simple" name="test_if_true_const" time="0.005" /><testcase classname="test_simple" name="test_varargs_return" time="0.009" /><testcase classname="test_simple" name="test_varargs_add" time="0.008" /><testcase classname="test_simple" name="test_call_varargs_add" time="0.025" /><testcase classname="test_simple" name="test_add_defaults" time="0.027" /><testcase classname="test_simple" name="test_call_add_defaults" time="0.005" /><testcase classname="test_simple" name="test_call_defaults_with_names" time="0.006" /><testcase classname="test_simple" name="test_call_pos_with_names" time="0.007" /><testcase classname="test_slices" name="test_implicit_slice_first_axis_matrices" time="0.058" /><testcase classname="test_slices" name="test_slice_first_axis_matrices" time="0.003" /><testcase classname="test_slices" name="test_slice_second_axis_matrices" time="0.062" /><testcase classname="test_slices" name="test_assign_first_axis" time="0.178" /><testcase classname="test_slices" name="test_assign_second_axis" time="0.187" /><testcase classname="test_slices" name="test_assign_slices" time="0.293" /><testcase classname="test_slices" name="test_assign_four_rows" time="0.751" /><testcase classname="test_slices" name="test_loop_slices" time="0.442" /><testcase classname="test_slices" name="test_lower_right_corner" time="0.102" /><testcase classname="test_thresholds" name="test_count_thresh" time="5.694" /><testcase classname="test_tiled_mm" name="test_par_mm" time="1.600" /><testcase classname="test_tiling" name="test_1d_map" time="1.613" /><testcase classname="test_tiling" name="test_2d_map" time="1.643" /><testcase classname="test_tiling" name="test_2_maps" time="1.589" /><testcase classname="test_tiling" name="test_1d_reduce" time="0.293"><failure type="exceptions.AssertionError" message="Mismatch between LHS type int64 and RHS float64 in 'result_before : int64 = 0.0 : float64'&#10;-------------------- &gt;&gt; begin captured stdout &lt;&lt; ---------------------&#10;prefix tile_params&#10;ssa_id tile_params.4&#10;type tuple(int64)&#10;prefix shape&#10;ssa_id shape.967&#10;type tuple(int64)&#10;prefix dim0&#10;ssa_id dim0.346&#10;type int64&#10;prefix tilesize&#10;ssa_id tilesize.6&#10;type int64&#10;prefix loop_result&#10;ssa_id loop_result&#10;type int64&#10;prefix result_before&#10;ssa_id result_before&#10;type int64&#10;prefix result_after&#10;ssa_id result_after&#10;type int64&#10;prefix i&#10;ssa_id i.1109&#10;type int64&#10;prefix next_bound&#10;ssa_id next_bound&#10;type int64&#10;prefix min_temp&#10;ssa_id min_temp&#10;type int64&#10;prefix indices&#10;ssa_id indices.11&#10;type tuple(SliceT(int64, int64, int64))&#10;prefix new_acc&#10;ssa_id new_acc&#10;type int64&#10;ERROR after running LowerTiledAdverbs on function red_fn2(X : array1(int64), tile_params.4 : tuple(int64)) =&gt; int64:&#10;    shape.967 : tuple(int64) = attr(X, 'shape')&#10;    dim0.346 : int64 = TupleProj(shape.967, 0)&#10;    tilesize.6 : int64 = TupleProj(tile_params.4, 0)&#10;    #&#10;    # TiledReduce in red_fn2: init_unpack&#10;    #&#10;    result_before : int64 = 0.0 : float64&#10;    #&#10;    # TiledReduce in red_fn2: combine&#10;    #&#10;    for i.1109 in range(0, dim0.346, tilesize.6):&#10;      (header)&#10;        loop_result &lt;- phi(result_before, result_after)&#10;      (body)&#10;        next_bound : int64 = i.1109 + tilesize.6&#10;        if next_bound &lt;= dim0.346:&#10;        (merge-if)&#10;            min_temp &lt;- phi(next_bound, dim0.346)&#10;        indices.11 : tuple(SliceT(int64, int64, int64)) = slice(i.1109, min_temp, 1)&#10;        #&#10;        # TiledReduce in red_fn2: map_fn &#10;        #&#10;        x.391 : array1(int64) = X[indices.11]&#10;        new_acc : int64 = Reduce(axis = 0, args = (x.391:array1(int64)), type = int64, init = 0 : int64, map_fn = function inner_block.4(x : int64) =&gt; int64:&#10;            Return x, combine = function add_x_y2(x : int64, y : int64) =&gt; int64:&#10;            Return x + y)&#10;        result_after : int64 = loop_result + new_acc&#10;    Return loop_result&#10;&#10;--------------------- &gt;&gt; end captured stdout &lt;&lt; ----------------------"><![CDATA[Traceback (most recent call last):
  File "/usr/lib/python2.7/unittest/case.py", line 327, in run
    testMethod()
  File "/usr/lib/python2.7/dist-packages/nose/case.py", line 197, in runTest
    self.test(*self.arg)
  File "/home/iskander/code/parakeet/tests/test_tiling.py", line 141, in test_1d_reduce
    new_fn = lower_tiled(red_fn2)
  File "/home/iskander/code/parakeet/parakeet/pipeline.py", line 125, in lower_tiled
    tiled = tiling.apply(fn, ignore_config = ignore_config)
  File "/home/iskander/code/parakeet/parakeet/pipeline_phase.py", line 93, in apply
    fn = apply_transforms(fn, self.transforms, cleanup = self.cleanup)
  File "/home/iskander/code/parakeet/parakeet/pipeline_phase.py", line 9, in apply_transforms
    fn = t.apply(fn)
  File "/home/iskander/code/parakeet/parakeet/transform.py", line 402, in apply
    verify.verify(new_fn)
  File "/home/iskander/code/parakeet/parakeet/verify.py", line 186, in verify
    Verify(fn).visit_block(fn.body)
  File "/home/iskander/code/parakeet/parakeet/syntax_visitor.py", line 183, in visit_block
    self.visit_stmt(s)
  File "/home/iskander/code/parakeet/parakeet/verify.py", line 167, in visit_stmt
    SyntaxVisitor.visit_stmt(self, stmt)
  File "/home/iskander/code/parakeet/parakeet/syntax_visitor.py", line 236, in visit_stmt
    self.visit_Assign(stmt)
  File "/home/iskander/code/parakeet/parakeet/verify.py", line 146, in visit_Assign
    (stmt.lhs.type, stmt.rhs.type, stmt)
AssertionError: Mismatch between LHS type int64 and RHS float64 in 'result_before : int64 = 0.0 : float64'
-------------------- >> begin captured stdout << ---------------------
prefix tile_params
ssa_id tile_params.4
type tuple(int64)
prefix shape
ssa_id shape.967
type tuple(int64)
prefix dim0
ssa_id dim0.346
type int64
prefix tilesize
ssa_id tilesize.6
type int64
prefix loop_result
ssa_id loop_result
type int64
prefix result_before
ssa_id result_before
type int64
prefix result_after
ssa_id result_after
type int64
prefix i
ssa_id i.1109
type int64
prefix next_bound
ssa_id next_bound
type int64
prefix min_temp
ssa_id min_temp
type int64
prefix indices
ssa_id indices.11
type tuple(SliceT(int64, int64, int64))
prefix new_acc
ssa_id new_acc
type int64
ERROR after running LowerTiledAdverbs on function red_fn2(X : array1(int64), tile_params.4 : tuple(int64)) => int64:
    shape.967 : tuple(int64) = attr(X, 'shape')
    dim0.346 : int64 = TupleProj(shape.967, 0)
    tilesize.6 : int64 = TupleProj(tile_params.4, 0)
    #
    # TiledReduce in red_fn2: init_unpack
    #
    result_before : int64 = 0.0 : float64
    #
    # TiledReduce in red_fn2: combine
    #
    for i.1109 in range(0, dim0.346, tilesize.6):
      (header)
        loop_result <- phi(result_before, result_after)
      (body)
        next_bound : int64 = i.1109 + tilesize.6
        if next_bound <= dim0.346:
        (merge-if)
            min_temp <- phi(next_bound, dim0.346)
        indices.11 : tuple(SliceT(int64, int64, int64)) = slice(i.1109, min_temp, 1)
        #
        # TiledReduce in red_fn2: map_fn 
        #
        x.391 : array1(int64) = X[indices.11]
        new_acc : int64 = Reduce(axis = 0, args = (x.391:array1(int64)), type = int64, init = 0 : int64, map_fn = function inner_block.4(x : int64) => int64:
            Return x, combine = function add_x_y2(x : int64, y : int64) => int64:
            Return x + y)
        result_after : int64 = loop_result + new_acc
    Return loop_result

--------------------- >> end captured stdout << ----------------------
]]></failure></testcase><testcase classname="test_transcendental" name="test_sin" time="1.379" /><testcase classname="test_transcendental" name="test_sinh" time="1.379" /><testcase classname="test_transcendental" name="test_cos" time="1.393" /><testcase classname="test_transcendental" name="test_cosh" time="1.402" /><testcase classname="test_transcendental" name="test_tan" time="1.407" /><testcase classname="test_transcendental" name="test_tanh" time="1.387" /><testcase classname="test_transcendental" name="test_log" time="1.404" /><testcase classname="test_transcendental" name="test_log10" time="1.459" /><testcase classname="test_transcendental" name="test_exp" time="1.434" /><testcase classname="test_tuples" name="test_return_pair" time="1.384" /><testcase classname="test_tuples" name="test_create_tuple" time="4.263" /><testcase classname="test_tuples" name="test_tuple_lhs" time="4.393" /><testcase classname="test_tuples" name="test_tuple_lhs_sum" time="2.815" /><testcase classname="test_tuples" name="test_tuple_indexing" time="4.238" /><testcase classname="test_tuples" name="test_or_elts" time="1.405" /><testcase classname="test_type_inference" name="test_add1" time="0.005" /><testcase classname="test_type_inference" name="test_call_add1" time="0.003" /><testcase classname="test_type_inference" name="test_add_bools" time="0.001" /><testcase classname="test_type_inference" name="test_branch_return" time="0.001" /><testcase classname="test_type_inference" name="test_branch_assign" time="0.002" /><testcase classname="test_type_inference" name="test_incr_loop" time="0.005" /></testsuite>